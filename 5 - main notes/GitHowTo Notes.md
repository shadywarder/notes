**2025-01-14 16:36**
Tags: [git](../2%20-%20tags/git.md) [[../2 - tags/tools]]

## GitHowTo Notes
### История
Получения списка произведенных изменений - функция команды `git log`.

```shell
git log
```

### Однострочная история

```shell
git log --pretty=oneline
```

```git
$ git log --oneline
b7614c1 Added HTML header
46afaff Added standard HTML page tags
78433de Added h1 tag
5836970 Initial commit
```

### Изощряемся

```shell
git log --all --pretty=format:"%h %cd %s (%an)" --since="7 days ago"
3d696c6 Tue Jan 14 16:50:40 2025 +0300 Added HTML header (setanoier)
20ea96c Tue Jan 14 16:50:00 2025 +0300 Added standard HTML page tags (setanoier)
383d725 Tue Jan 14 16:45:30 2025 +0300 Added h1 tag. (setanoier)
5217222 Tue Jan 14 16:41:50 2025 +0300 Initial Commit (setanoier)
```

### Конечный формат лога

```shell
git log --pretty=format:"%h %ad | %s%d [%an]" --date=short
3d696c6 2025-01-14 | Added HTML header (HEAD -> main) [setanoier]
20ea96c 2025-01-14 | Added standard HTML page tags [setanoier]
383d725 2025-01-14 | Added h1 tag. [setanoier]
5217222 2025-01-14 | Initial Commit [setanoier]
```

- `--pretty="..."` - определяет формат вывода.
- `%h` - укороченный хеш коммита.
- `%ad` - дата коммита.
- `|` - просто визуальный разделитель.
- `%s` - комментарий.
- `%d` - дополнения коммита ("головы" веток или теги).
- `%an` - имя автора.
- `--date=short` - сохраняет формат даты коротким и симпатичным.

### Создание тегов версий

```go
git tag v1
```

Теперь текущая версия страницы называется `v1`.

### Теги для предыдущих версий 
Обозначим версию, предшествующую текущей, названием `v1-beta`. Сначала нам нужно переключиться на предыдущию версию, мы будем использовать `^` вместо того, чтобы искать хеш коммита.

```shell
git checkout v1^
```

### Переключение по имени тега
Попробуем попереключаться между двумя отмеченными версиями.

```shell
git checkout v1
git checkout v1-beta
```

### Просмотр тегов с помощью команды `tag`
Вы можете увидеть, какие теги доступны, используя команду `git tag`.

```shell
git tag
```

### Отмена локальных изменений (до индексации)
Иногда после того как мы что-то изменили в рабочей директории, мы можем передумать и просто захотеть вернуться к тому, что уже было закоммичено. Команда `checkout` справится с этой задачей.

Внесем изменение в файл `hello.html` в виде нежелательного комментария.
Используем команду `checkout` для переключения в версию файла `hello.html` в репозитории.

```shell
git checkout hello.html
```

### Отмена проиндексированных изменений (перед коммитом)
Внесем изменение в файл `hello.html` в виде нежелательного комментария.
Проиндексируем это изменение.

```shell
git add hello.html
```

Команда `reset` сбрасывает область подготовки к `HEAD`. Это очищает область подготовки от изменений, которые мы только что проиндексировали.

```shell
git reset HEAD hello.html
```

Команда `reset` не изменяет рабочую директорию по умолчанию. Поэтому рабочая директория все еще содержит нежелательный комментарий. Можно использовать команду `checkout`, чтобы убрать нежелательные изменения в рабочей директории.

```shell
git checkout hello.html
```

Наша рабочая директория опять чиста.

### Отмена коммитов
Иногда мы понимаем, что новые коммиты являются неверными, и хотим их отменить. Есть несколько способов решения этого вопроса, здесь мы будем использовать самый безопасный. Мы отменим коммит путем создания нового коммита, отменяющего нежелательные изменения.

Чтобы отменить коммит, нам необходимо сделать, который удаляет изменения, сохраненные нежелательным коммитом.

```shell
git revert HEAD
```

Так как мы отменили самый последний произведенный коммит, мы смогли использовать метку `HEAD` в качестве аргумента для отмены коммита. Мы можем отменить любой произвольный коммит в истории, указав его хеш.

### Удаление коммитов из ветки
Мы уже видели команду `reset` и использовали ее для согласования области подготовки с выбранным коммитом (в предыдущем уроке мы использовали коммит `HEAD`).

Если выполнить комманду `reset` с указанием ссылки на коммит (т.е. метки `HEAD`, имени ветки или тега, хеша коммита), то команда...
1. Изменит текущую ветку, чтобы она указывала на указанный коммит.
2. Опционально сбросит область подготовки до соответствия с указанным коммитом.
3. Опционально сбросить рабочую директорию до соответствия с указанным коммитом.

Прежде чем удалить коммиты давайте отметим последний коммит тегом, чтобы потом можно было его найти.

```shell
git tag oops
```

Глядя на историю лога, мы видим, что коммит с тегом `v1` является коммитом, предшествующим ошибочному коммиту. Давайте сбросим ветку до этой точки. Поскольку ветка имеет тег, мы можем использовать имя тега в команде сброса `reset` (если она не имеет тега, мы можем использовать хеш коммита).

```shell
git reset --hard v1
```

Наша ветка `main` теперь указывает на коммит `v1`, а коммитов "Revert Oops" и "Oops" в ветке уже нет. Параметр `--hard` указывает, что рабочая директория должна быть приведена к тому состоянию, которое соответствует `HEAD`-коммиту ветки.

Ошибочные коммиты все еще находятся в репозитории и мы все еще можем на них ссылаться. 

```shell
git log --all
```

Мы видим, что ошибочные коммиты не исчезли, они все еще находятся в репозитории. Просто они отсутствуют в ветке `main`. Если бы мы не отметили их тегами, они по-прежнему находились бы в репозитории, но не было бы никакой возможносьт ссылаться на них, кроме как при помощи хешей этих коммитов. Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора.

### Удаление тега `oops`
Тег `oops` свою функцию выполнил, давайте удалим его. Это позволит внутреннему механизму Git убрать остаточные коммиты, на которые не ссылаются никакие ветки или теги.

```go
git tag -d oops
git log --all
```

### Внесение изменений в коммиты
Допустим мы закоммитили какие-то изменения.

```shell
git add hello.html
git commit -m "Added copyright statement"
```

Однако после создания коммита вы понимаете, что забыли какую-то маленькую деталь, для которой не хочется создавать отдельный коммит. Давайте изменим предыдущий коммит, включив в него нужную нам деталь/

```shell
git add hello.html
git commit --amend -m "Added copyright statement with email"
```

Такого же эффекта можно достичь путем сброса последнего коммита в ветке, и повторного коммита новых изменений.

### Создание ветки
Разработка новой функциональности всегда связана с риском: разработка может занять много времени, вы можете в конечном итоге отказаться от нее и т. д. По этой причине лучше всего изолировать разработку фичи в отдельной ветке. Когда фича будет готова, вы сможете слить эту ветку с веткой `main`. До того времени ветка `main` будет защищена от рискованного и непроверенного кода. Кроме того, вы можете работать над несколькими фичами параллельно, на каждой в собственной ветке. Вы также можете в любой момент вносить изменения в ветке `main`, например, чтобы исправить ошибку в стабильном коде.

```shell
git switch -c style
git status
```

Мы можем также создавать ветки командой `git checkout -b style`, но эта команда перегружена функциями и флагами. Старый способ все еще работает, но он не рекомендуетсяс. Новая комманда `git switch` более выразительна и менее восприимчива к ошибкам.

### Переключение веток
Переключение на ветку `main`.

```shell
git switch main
```

### Перемещение файлов
Давайте переименуем файл `hello.html` в `index.html`. Также давайте перенесем наш файл стилей в специально отведенную директорию `css`.

Git позволяет просматривать историю изменений конкретного файла.

```shell
git log hello.html
git log style.css
```

**Просмотр различий для конкретного файла**
Команда `show` используется для просмотра изменений в конкретном коммите. Посмотрим изменения в файле `hello.html` в коммите, с тегом `v1` (можно использовать любую ссылку на коммит, например, метку `HEAD`, хеш коммита, имя ветки или тега и т.д.).

```shell
git show v1
```

**Переименуйте файл `hello.html`**
```shell
mv hello.html index.html
git status
```

Git воспринимает наше изменение так, будто файл был удален и создан заново. В простейшем случае Git сам поймет, что файл был переименован, как только мы добавим его в индекс:

```shell
git add .
git status

On branch style
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    hello.html -> index.html
```

Это не всегда работает. Например, если вы переименовали, **а также** изменили кучу файлов, Git может оказаться не в состоянии понять, что именно было переименовано.

**Переместите `style.css` безопасным способом**
Давайте переместим наш файл `style.css` в директорию `css` , но на этот раз сделаем это безопасно с помощью команды `git mv`. Это команда гарантирует, что перемещение будет записано в истории Git как перемещение.

```shell
mkdir css
git mv style.css css/style.css
```

Давайте закоммитим наши изменения и проверим историю изменений в файле `css/styles.css`. Для просмотра истории файла до его перемещения нам потребуется добавить опцию `--follow`. 

```shell
git commit -m "Renamed hello.html; moved style.css"
git log css/style.css
3dbcfeb 2025-01-15 | Renamed hello.html; moved style.css (HEAD -> style) [shadywarder]
git log --follow css/style.css
3dbcfeb 2025-01-15 | Renamed hello.html; moved style.css (HEAD -> style) [shadywarder]
6c33868 2025-01-15 | Added css stylesheet [shadywarder]
```

### Изменения в ветке `main`
Добавления `README` файла в ветку `main`.

```shell
echo "This is the Hello World example from the GitHowTo." > README.md
git switch main
git add README.md
git commit -m "Added README"
```

### Просмотр отличающихся веток
Теперь у нас есть две расходящиеся ветки в репозитории. Используем комманду `log` для просмотра веток и их расхождения!

```shell
git log --all --graph
```

Опция `--all` гарантирует, что мы видим все ветки, так как по умолчанию в логе показывается только текущая ветка.

Опция `--graph` добавляет простое дерево коммитов, представленное в виде простых текстовых линий. Мы видим обе ветки (`style` и `main`) причем ветка `main` помечена как `HEAD`, что означает, что она является текущей. Общим предком для обеих веторк является ветка, в которую был внесен коммит "Added copyright statement with email".

### Слияние
Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке `style` и сольем `main` со `style`.

```shell
git switch style
git merge main
```

Путем переодического слияния ветки `main` с веткой `style` вы можете переносить из `main` любые изменения и поддерживать совместимость изменений `style` с изменениями в основной ветке.

Однако, это делает графы коммитоа действительно уродливыми. Позже мы рассмотрим возможность перебазирования, как альтернативы слиянию.

### Создание конфлитка
В нашей ветке `main` страница по-прежнему называется `hello.html`. Переключимся обратно и внесем изменения в этот файл.

```shell
git switch main
git add hello.html
git commit -m "Added meta title"
```

После коммита "Added README" ветка `main` была объединена с веткой `style`, но в настоящее время в `main` есть дополнительный коммит, который не был слит с `style`.

Последнее изменения в `main` конфликтует с некоторыми изменениями в `style`. На следующем шаге мы решим этот конфликт.

### Разрешение конфликтов

```shell
git switch style
git merge main
Auto-merging index.html
CONFICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and the commit the results
```

```html
<html>
  <head>
<<<<<<< HEAD:index.html
    <link type="text/css" rel="stylesheet" media="all" href="style.css" />
=======
    <title>Hello World Page</title>
>>>>>>> main:hello.html
  </head>
  <body>
    <h1>Hello, World!</h1>
    <p>Let's learn Git together.</p>
  </body>
</html>
```

Часть между `<<<<<<<` `>>>>>>>` является конфликтом. Верхняя часть соответствует ветке `style`, которая является текущей веткой (или `HEAD`) репозитория. Нижняя часть соответствует изменениея из ветки `main`. Git не может решить, какие изменения применить, поэтому он просит вас разрешить конфликт вручную. Вы можете оставить изменения из ветки `style` или из `main`, либо объединить их любым удобным способом. Вы также можете внести в файл любые другие изменения.

**Отмена слияния**
Важно отметить, что бросаться к разрешению конфликта не всегда оптимально. Конфликт может быть вызван изменениями, о которых вы не знаете. Или же изменения слишком велики, чтобы разрешить конфликт сразу. По этой причине Git позволяет прервать слияние и вернуться к предыдущему состоянию. Для этого можно воспользоваться командой `git merge --abort`.

```shell
git merge --abort
```

**Решение конфликта**
Давайте снова запустим объединение. 

```shell
git merge main
```

Чтобы разрешить конфликт, нужно отредактировать файл до состояния, которое нас устраивает, и затем закоммитить его как обычно. В нашам случае мы объединим изменения из обеих веток.

Теперь нам нужно закоммитить разрешенный конфликт.

```shell
git add index.html
git commit -m "Resolved merge conflict"
```

### `rebase` против `merge`
Давайте рассмотрим отличия между слиянием и перебазированиеи. Для того чтобы это сделать, нам нужно вернуться в репозиторий в момент до первого слияния, а затем повторить те же действия, но с использованием перебазирования вместо слияния.

Мы будем использовать команду `reset` для возврата к предыдущем изменению.

### Сброс ветки `style`
Давайте вернемся во времени на ветке `style` к точке *перед* тем, как мы слили ее с веткой `main`.

```git
*   79ac6fa 2023-11-28 | Resolved merge conflict (HEAD -> style) [Alexander Shvets]
|\  
| * 85c14e9 2023-11-28 | Added meta title (main) [Alexander Shvets]
* | a33deed 2023-11-28 | Merge branch 'main' into style [Alexander Shvets]
|\| 
| * ee16740 2023-11-28 | Added README [Alexander Shvets]
* | 0ee0113 2023-11-28 | Renamed hello.html; moved style.css [Alexander Shvets]
* | 903eb1d 2023-11-28 | Included stylesheet into hello.html [Alexander Shvets]
* | 555372e 2023-11-28 | Added css stylesheet [Alexander Shvets]
|/  
* 9288a33 2023-11-28 | Added copyright statement with email [Alexander Shvets]
* b7614c1 2023-11-28 | Added HTML header (tag: v1) [Alexander Shvets]
* 46afaff 2023-11-28 | Added standard HTML page tags (tag: v1-beta) [Alexander Shvets]
* 78433de 2023-11-28 | Added h1 tag [Alexander Shvets]
* 5836970 2023-11-28 | Initial commit [Alexander Shvets]
```

 Это немного трудно читать, но, глядя на данные, мы видим, что коммит "Renamed hello.html; moved style.css" был последним на ветке `style` перед слиянием. Давайте сбросим ветку `style` к этому коммиту. Чтобы сослаться на этот коммит, мы либо используем его хеш, либо посчитаем, что этот коммит находится за 2 коммита до `HEAD`, то есть `HEAD~2` в нотации Git.

```shell
git reset --hard HEAD~2
```

### Перебазирование 
Мы вернули ветку `style` к точке перед новым слиянием. При этом в ветке `main` есть два коммита, которых нет в ветке `style`: новый файл `README` и конфликтующее изменение в файле `index.html`. На этот раз мы перенесем это изменения в ветку `style` с помощью команды `rebase`, а не `merge`.

```shell
git rebase main
git status
```

```git
$ git rebase main
Rebasing (1/3)
Rebasing (2/3)
Auto-merging hello.html
CONFLICT (content): Merge conflict in hello.html
error: could not apply 903eb1d... Included stylesheet into hello.html
hint: Resolve all conflicts manually, mark them as resolved with
hint: "git add/rm <conflicted_files>", then run "git rebase --continue".
hint: You can instead skip this commit: run "git rebase --skip".
hint: To abort and get back to the state before "git rebase", run "git rebase --abort".
Could not apply 903eb1d... Included stylesheet into hello.html
$ git status
interactive rebase in progress; onto 85c14e9
Last commands done (2 commands done):
   pick 555372e Added css stylesheet
   pick 903eb1d Included stylesheet into hello.html
Next command to do (1 remaining command):
   pick 0ee0113 Renamed hello.html; moved style.css
  (use "git rebase --edit-todo" to view and edit)
You are currently rebasing branch 'style' on '85c14e9'.
  (fix conflicts and then run "git rebase --continue")
  (use "git rebase --skip" to skip this patch)
  (use "git rebase --abort" to check out the original branch)

Unmerged paths:
  (use "git restore --staged <file>..." to unstage)
  (use "git add <file>..." to mark resolution)
	both modified:   hello.html

no changes added to commit (use "git add" and/or "git commit -a")
```

Опять возник конфликт! Обратите внимание, что конфликт возник в файле `hello.html`, а не в файле `index.html`, как в прошлый раз. Это связано с тем, что `rebase` находился в процессе применения изменений `style` поверх ветки `main`. Файл `hello.html` в `main` еще не был переименован, поэтому он все еще имеет старое имя.

При слиянии возник бы "обратный" конфликт. При слиянии изменения ветки `main` были бы применены поверх ветки `style`. В ветке `style` файл переименован, поэтому конфликт возник бы в файле `index.html`.

**Разрешение конфликта**
Сам конфликт может быть разрешен тем же способом, что и предыдущий. Сначала мы изменим файл `hello.html`, чтобы он соответствовал нашим ожиданиям.

Но после этого нам не нужно коммитить изменения. Мы можем просто проиндексировать файл и продолжить процесс `rebase`. `rebase` позволяет устранять конфликты, не создвая кучу уродливых конфликтов слияния.

```shell
git add .
git rebase --continue
```

**Слияние vs. перебазирование**
Конечный результат перебазирования очень похож на результат слияния. Ветка `style`в настоящее время содержит все свои изменения, а также все изменения ветки `main`. Однако, дерево коммитов значительно отличается. Дерево коммитов ветки `style` было переписано таким образом, что ветка `main` является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.

**Когда использовать команду `rebase`, а когда команду `merge`**?
Использовать комманду `rebase`:
- Когда вы получаете изменения из удаленного репозитория и хотите применить их к своей локальной ветке.
- Если вы хотите, чтобы истории коммитов была линейной и легко читаемой.

Не используйте команду `rebase`:
- Если текущая ветка является публичной и общей. Переписывание таких веток будет мешать работе других членов команды.
- Если важна *точная* история ветки коммитов (поскольку команда `rebase` переписывает историю коммитов).

Учитывая приведенные выше рекомендации, я предпочитаю использовать команду `rebase` для краткосрочных, локальных веток и команду `merge` для веток в публичном репозитории.

### Слияние в ветку `main`
Мы поддерживали соответствие ветки `style` с веткой `main` (с помощью `rebase`), теперь давайте сольем изменения `style` в ветку `main`.

```shell
git switch main
git merge style
```

Поскольку последний коммит в `main` предшествует последнему коммиту ветки `style`, Git может выполнить ускоренное слияние, просто переместив указатель ветки вперед, на тот же коммит, что и ветка `style`.

При ускоренном слиянии конфликты не возникают. Кроме того, при ускоренном слиянии не создается фиксация не создается фиксация слияния.

### Клонирование репозиториев
Сейчас мы находимся в директории `repositories`.
Давайте создадим клон репозитория `work`.

```shell
git clone work home
```

### Что такое origin

```shell
git remote
origin
```

Мы видим, что клонированный репозиторий знает об имени по умолчантю удаленного репозитория. Давайте посмотрим, сможем ли мы получить более подробную информацию об имени по умолчанию:

```shell
git remote show origin
* remote origin
  Fetch URL: /home/stnr/repositories/work
  Push  URL: /home/stnr/repositories/work
  HEAD branch: main
  Remote branches:
    main  tracked
    style tracked
  Local branches configured for 'git pull':
    main  merges with remote main
    style merges with remote style
  Local refs configured for 'git push':
    main  pushes to main  (up to date)
    style pushes to style (up to date)
```

Мы видим, что имя по умолчанию (`origin`) удаленного репозитория - изначальное `work`. Удаленные репозитории обычно размещаются на отдельной машине, возможно, централизованном сервере. Однако, как мы видим здесь, они могут с тем же успехом указывать на репозиторий на той же машине. Нет ничего особенного в имени `origin`, однако существует традиция использовать `origin` в качестве имени первичного централизованного репозитория (если таковой имеется).

### Удаленные ветки
Давайте посмотрим на ветки, доступные в нашим клонированном репозитории.

```shell
git branch
* main
```

Как мы видим, в списке только ветка `main`. Где ветка `style`? Команда `git branch` выводит только список локальных веток по умолчанию.

**Список удаленных веток**
Для того чтобы увидеть все ветки, попробуйте следующую команду:

```shell
git branch -a
* main
  style
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
  remotes/origin/style
```

Git выводит все коммиты в оригинальный репозиторий, но ветки в удаленном репозитории не рассматриваются как локальные. Если мы хотим иметь собственную ветку `style`, мы должны сами ее создать.

### Изменение оригинального репозитория

```shell
cd ../work
git add README
git commit -m "Changed README in original repo"
```

Теперь в оригинальном репозитории есть более поздние изменения, которых нет в клонированной версии. Далее мы подтянем и сольем эти изменения в клонированный репозиторий.

### Подтягивание изменений

```shell
git fetch
From /home/alex/githowto/repositories/work
   39a1e0f..71df43a  main       -> origin/main
git log --all --graph
* 71df43a 2023-11-28 | Changed README in original repo (origin/main, origin/HEAD) [Alexander Shvets]
* 39a1e0f 2023-11-28 | Renamed hello.html; moved style.css (HEAD -> main, origin/style) [Alexander Shvets]
* 23149b5 2023-11-28 | Included stylesheet into hello.html [Alexander Shvets]
* b9e6de1 2023-11-28 | Added css stylesheet [Alexander Shvets]
* 85c14e9 2023-11-28 | Added meta title [Alexander Shvets]
* ee16740 2023-11-28 | Added README [Alexander Shvets]
* 9288a33 2023-11-28 | Added copyright statement with email [Alexander Shvets]
* b7614c1 2023-11-28 | Added HTML header (tag: v1) [Alexander Shvets]
* 46afaff 2023-11-28 | Added standard HTML page tags (tag: v1-beta) [Alexander Shvets]
* 78433de 2023-11-28 | Added h1 tag [Alexander Shvets]
* 5836970 2023-11-28 | Initial commit [Alexander Shvets]
```

На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.

Обратим внимание, что коммит "Changed README in original repo" включает в себя коммиты `origin/main` и `origin/HEAD`.

Локальная ветка указывает на коммит "Renamed hello.html; moved style.css", а не на новый коммит, который мы только что подтянули.

Получается, что команда `git fetch` будет подтягивать новые коммиты из удаленного репозитория, но не будет сливать их с вашими наработками в локальных ветках.

Клонированный `README` файл никак не изменился.

### Слияние подтянутых изменений

```shell
git merge origin/main
```

Проверив файл `README`, мы можем увидить, что изменения теперь есть.

Команда `fetch` позволяет контролировать то, что именно подтягивается и сливается в ваши локальные ветки, но для удобства существует также команда `pull`, которая подтягивает и сливает изменения из удаленной ветки в текущую одним вызовом.

```shell
git pull
```

... эквивалентна следующим двум шагам:

```shell
git fetch 
git merge origin/main
```

### Добавление ветки наблюдения
Ветки, которые начинаются c `remotes/origin` являются ветками оригинального репозитория. Обратите внимание, что у нас больше нет ветки под названием `style`, но система контроля версий знает, что в оригинальном репозитории ветка `style` была.

```shell
git branch --track style origin/style
git branch -a
git log --max-count=2
* 71df43a 2023-11-28 | Changed README in original repo (HEAD -> main, origin/main, origin/HEAD) [Alexander Shvets]
* 39a1e0f 2023-11-28 | Renamed hello.html; moved style.css (origin/style, style) [Alexander Shvets]
```

Теперь мы можем видеть ветку `style` в списке веток и логе.

### Чистые репозитории
Чистый репозиторий - это репозиторий, не имеющий рабочей директории. Он содержит только директорию `.git`, в которой Git хранит все свои внутренние данные. Основное предназначение таких репозиториев - быть центральным хранилищем, в которое разработчики могут отправлять и из которого могут получать данные. Поэтому в них нет смысла создавать рабочие файлы, они будут только впустую занимать место на диске. Чистые репозитории также используются в сервисах Git-хостинг таких, как GitJub и GitLab. 

```shell
cd ..
git clone --bare work work.git
ls work.git
```

Принято считать, что репозитории, заканчивающиеся на `.git`, являются чистыми репозиториями. Мы видим, что в репозитории `work.git` нет рабочей директории. По сути, это просто директория `.git` из обычного репозитория.

### Добавление удаленного репозитория
Давайте добавим репозиторий `work.git` к нашему оригинальному репозиторию.

```shell
cd work
git remote add shared ../work.git
```

### Отправка изменений
Поскольку чистые репозитории обычно располагаются на каком-либо удаленном сервере, вы не сможете туда просто зайти, дабы подтянуть изменения. Поэтому нам необходимо как-нибудь передать наши изменения в репозиторий.

Начним с создание изменения, которое нужно передать в репозиторий. 

```shell
git switch main
git add README
git commit -m "Added shared comment to README"
git push shared main
```

*Общим* называется репозиторий, получающий отправленные нами изменения. Мы добавили его в качестве репозитория на прошлом шаге.

```shell
git push shared main
To ../work.git
   71df43a..d9d2bea  main -> main
```

### Подтягивание общих изменений

```shell
git ../home
git remote add shared ../work.git
git pull shared main
cat README
```
## References
[GitHowTo](https://githowto.com/ru)