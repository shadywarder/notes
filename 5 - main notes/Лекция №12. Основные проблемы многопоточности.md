**2025-02-02 11:36**
**Tags:** [concurrency](../2%20-%20tags/concurrency.md)

## Лекция №12. Основные проблемы многопоточности
Основной источник проблем - общий доступ к распределенным ресурсам, а именно:
- исходному году программы
- памяти процесса
- процессорному времени

Все проблемы можно разделить на три больших категории:
- **Недостаточность синхронизации**
	- Race Condition
	- Data Race
- **Избыточность или некорректность синхронизации**
	- Deadlock
	- Livelock
	- Деградация производительности
- **Нехватка / некорректная утилизация ресурсов**
	- Thread Starvation
	- Деградация производительности

### Недостаточность синхронизации
#### Race Condition
Несколько потоков получают доступ к ресурсу и выполняют несколько неатомарных операций. Race condition происходит, когда время или порядок действий влияет на корректность куска кода.

#### Data Race
Data race происходит когда один поток получает доступ к мутабельному объекту в том время как другой что-то в него пишет.

![](../attachments/Pasted%20image%2020250202115733.png)

**Критическая секция** - участок исполняемого кода программы, в котором производится доступ к общему ресурсу (данным или устройству), которой не должен быть одновременно использовани более чем одним потоком выполнения. Иначе возникает состояние гонки (race condition).

#### Алгоритм Петерсона

![](../attachments/Pasted%20image%2020250202120156.png)

Нет никакой детерминированности для порядка предоставления доступа к критической секции для поток.

#### Алгоритм Лампорта

![](../attachments/Pasted%20image%2020250202123411.png)

#### Семафор
Примитив синхронизации работы процессов и потоков, в основе которого лежит счетчик, над которым можно производить две атомарные операции: **увеличение** и **уменьшение** значения на единицу, при этом операция уменьшения для нулевого значения счетчика является блокирующеся. Данные операции должны быть атомарными.

```c
void wait(Semaphore s) {
	while (s.get() == 0) {
		// bust waiting
	}
	s.decrement()
}

void signal(Semaphore s) {
	s.increment()
}
```

![](../attachments/Pasted%20image%2020250202130206.png)

![](../attachments/Pasted%20image%2020250202130230.png)

```
n = the number of threads
count = 0
mutex = Semaphore(1)
barrier = Semaphore(0)

mutex.wait(1)
count = count + 1
mutext.signal()

if count == n: barrier.signal() # unblock ONE thread

barrier.wait()
barrier.signal() # once we are unblocked, it's our duty to unblock the next thread
```

### Неблокирующая синхронизация
Основные недостатки блокирующей синхронизации:
- Заблокированный поток невозможно использовать
- Некорректная синхронизция может повлечь за собой блокировку работы всей системы (дедлоки)

**Read-Modify-Write операции** - класс операций, совмещающих в одну атомарную с точки зрения процессора операцию сразу несколько - чтение и модификацию значения. К ним относят Compare-And-Swap (CAS), Fetch-and-Add(FAA), Load-Link/Store-Conditional (LL/SC) и другие.


## References
[Академия Бэкенда Лекция №12](https://tbank.ktalk.ru/recordings/go5DtUTVmqUiganUzYxJ)