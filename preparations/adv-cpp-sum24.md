1. ***Этапы компиляции. Препроцессор: директивы и макроподстановки;***

Этапы компиляции:
1. **Препроцессор.** Обработка исходного кода (preprocessing);
2. **Компиляция.** Перевод подготовленного исходного кода в ассемблерный код;
3. **Ассебмлирование.** Перевод ассемблерного кода в объектные файлы;
4. **Компоновка**. Сборка одного или неескольких объектных файлов в один исполняемый файл.

**Препроцессор**
Делаются макроподстановки
- определения (`#define`, `#undef`);
    
Объектно-подобный макрос `#define <NAME> <CODE>`
Функционально-подобный макрос `#define <NAME>(<PARAMETERS>) <CODE>`

```cpp
/* Если при использовании PI будет ошибка компиляции, то в сообщение от компилятора увидите значение 3.141592, а не PI! */
#define PI 3.141592 


#define MAX(x, y) ( x > y ? x : y )
int a = 5; 
std::cout << MAX(++a, 0) << std::endl; // a увеличится два раза! 
std::cout << MAX(++a, 10) << std::endl; // а тут всего лишь один раз!

#define MULT(x, y) x * y
std::cout << MULT(1+2, 3+4) << std::endl; // 1+2*3+4
```
- условные включения (`#ifded`, `#ifndef`, `#if`, `#endif`, `#else`, `#elifdef`, `#elifndef` и `#elif`)
```cpp
#ifndef MY_MACRO
std::cout << “Hello” << std::endl;
#else
std::cout << “Bye” << std::endl;
#endif
```

```Shell
$ g++ -std=c++20 macro.cpp -o macro
$ ./macro
Hello
$ g++ -std=c++20 -DMY_MACRO macro.cpp -o macro
$ ./macro
Bye 
```
- директива `#line`
```cpp
#line 20 "assigning variable"
int a?;
```

```Shell
assigning variable:20:6: error: expected initializer before ‘?’ token
```

- директива `#error`, `#warning`
```cpp
#include<stdio.h>
#ifndef __MATH_H
#error First include then compile
#else
int main(){
    float a,b=25;
    a=sqrt(b);
    printf("%f",a);
    return 0;
}
#endif
```

```Shell
main.cpp:3:2: error: #error First include then compile
    3 | #error First include then compile
      |
```

- директива `#pragma`
- Подстановка предопределенных макросов (`__LINE__`, `__FILE__`, `__DATE__`, `__cplusplus` etc.)
- Результат обработки препроцессором исходного файла называется единицей трансляции (translation unit).
- Выполняются директивы `#include`
    - `#include "name"` - целиком вставляет файл с именем `"name"`, вставляемый файл также обрабывается препроцессором. Поиск файла происходит в директории с файлом, из которого происходит включение;
    - `#include <name>` - аналогично предыдущей директиве, но поиск производится в глобальных директориях и директориях, указанных с помощью ключа `"-I"`

Полезная статья: https://cplusplus.com/doc/tutorial/preprocessor/

---

2. ***Объектный файл. Декорирование. Компоновщик***

**Объектный файл**
Определяется форматом `ELF (Executable and Linkable Format)` на Unix-подобных системах

Существует три разновидности объектных файлов
- **Перемещаемый объектный файл (Relocatable object file)** - можно компоновать с другими объектными файлами для создания исполняемых или общих общих объектных файлов.
- **Исполняемый объектный файл (Executable object file)** - можно запускать; в файле указано, как exec (базовая операционная система) создаст образ процесса программы.
- **Разделяемый объектный файл (Shared object file)** - загружаются в память в время исполнения.

Полезная статья: https://carsontang.github.io/unix/2013/06/01/guide-to-object-file-linking/

Состоит из секций
- Машинный код (`.text`)
- Инициализированные данные, с правами на чтение и запись (`.data`)
- Иницилазированные данные, с правами только на чтение (`.rodata`)
- Неинициализированные данные, с правами на чтение/запись (`.bss`)
- Таблица символов (`.symtab`)

Символы - то, что находится в объектном файле - кортежи из
- Имя - произвольная строка;
- Адрес - число (смещение, строка);
- Свойства: тип связывания (binding) (доступен ли символ вне файла);

**Декорирование (mangling)**

> It provides a unique name for each class member and global/namespace function and variable, so namespace and class names (for resolution) and argument types (for overloading) are somehow included in the final linker names.

*Глобальные символы*
- Символы определенные в одном модуле таким образом, что их можно использовать в других модулях;
- Например: не-static функции и не-static глобальные переменные;

*Внешние (неопределенные) символы*
- Глобальные символы, которые используются в модуле, но определены в каком-то другом модуле.

*Локальные символы*
- Символы определены и используются исключительно в одном модуле.
- Например: функции и переменные, определенные с модификатором `static`.
- Локальные символы не являются локальными переменными программы

**Компоновка**
Компоновщик собирает из одного и более объектных файлов исполняемый файл.

```Shell
$ g++ -o my_prog main.o square.o
$ ./my_prog
$ echo $?
4
```

- Организация программы как набор файлов с исходным кодом, а не один монолитный файл.
-  Организовывать библиотеки функций, являющихся общими для разных программ;
-  Раздельная компиляция:
    - Меняем код в одном файле, компилируем только его, повторяем компоновку;
    - Нет необходимости повторять компиляцию остальных файлов с исходным кодом.
-  Исполняемые файлы и образ программы в памяти содержит только те функции, которые действительно используются.

---

3. ***Запуск программы. Размещение сегментов в памяти. Виртуальная память.***

**Запуск программы** 
Программы на языке C/C++ начинают свою работу с вызова функции `main` 

```cpp
int main()
int main(int argс, char **argv)
int main(int argc, char **argv, char **env)
```

`int argc` - Number of strings in array `argv`
`char **argv` - Array of command-line argument strings
`char **env` - Array of environment variable strings

Полезная статья: https://en.cppreference.com/w/cpp/language/main_function

Перед вызовом функции `main` выполняется специальная процедура начального запуска;
Процедура начального запуска спроектирована так, что она вызывает функцию `exit`, когда происходит возврат из функции `main`.
`exit(main(argc, argv));`

**Типичное размещение сегментов в памяти**
*Сегмент кода (text)* - машинные инструкции, которые выполняются центральным процессором;
*Сегмент инициализированных данных (data)* - содержит переменные, которые инициализированы определенными значениями в тексты программы;
*Сегмент неинициализированных данных (bss)* - сегмент неинициализированных данных;
*Сегмент стека (stack)* - хранятся переменные с автоматическим классом размещения, а также информация, которая сохраняется при каждом вызове функции.
*Куча (heap)* - область динамической памяти

![[Pasted image 20240715221620.png]]

**Виртуальная память**
- Память делится на страницы;
- Страница может находится в оперативной памяти или на внешнем носителе;
- Трансляция из физического адреса в виртуальный и обратно выполняется через специальные таблицы: **PGD** (Page Global Directory), **PMD** (Page Middle Directory) и **PTE** (Page Table Entry). В **PTE** хранятся физические адреса страниц;
- Для ускорения трасляции адресов процессор хранит в кеше таблицу **TLB** (Translation lookaside buffer);
- Если обращение к памяти не может быть оттранслировано через **TLB**, то процессор обращается к таблицам страниц и пытается загрузить **PTE** оттуда в **TLB**. Если загрузка не удалась, процессор вызывает прерывание Page Fault.
- Обработчик прерывания Page Fault находится в подсистеме виртуальной памяти ядра ОС и может загрузить требуемую страницу с внешнего носителя в оперативную память.

![[Pasted image 20240716005914.png]]

- Стараться укладывать данные в кеш;
- Минимизировать скачки по памяти;
- В условиях основной ветки делать ветку, которая выполняется с большей вероятностью.

Полезные статьи: 
https://courses.grainger.illinois.edu/cs240/sp2021/notes/virtualMemory-heap-stack.html
https://www.cprogramming.com/tutorial/virtual_memory_and_heaps.html

---

4. ***Классы управления памятью, кеш-память, стек, куча.***

**Классы управления памятью и областью видимости** 
Характеризуются тремя понятиями:
- *Время жизни.* Продолжительность хранения данных в памяти;
- *Область видимости.* Части кода, из которых можно получить доступ к данным.
- *Связывание (linkage).* Если к данным можно обратиться из другой единицы трансляции - связывание внешнее (external), иначе связывание внутреннее (internal);

1. Автоматический/регистровый (register)
- *Время жизни:* автоматическое (блок)
- *Область видимости:* блок
- *Связывание:* отсутствует 

```cpp
{
    int i = 5;
}

if (true) {
    register* int j = 3; 
}
```

Ключевое слово `register` до С++17 deprecated, с С++17 ключевое слово не используется и зарезервировано.

2. Статический без связывания
- *Время жизни:* статическое
- *Область видимости:* блок
- *Связывание:* отсутствует 

```cpp
void foo() {
    static int j = 3;
}
```


3. Статический с внутренним связыванием
- *Время жизни:* статическое
- *Область видимости:* блок
- *Связывание:*  внутреннее 

```cpp
static int j = 5;
```

Инициализируется до входа в `main`.

4. Статический с внешним связыванием
- *Время жизни:* статическое
- *Область видимости:* файл
- *Связывание:* внешнее

```cpp
//  *.cpp
int i = 0;
// *.hpp
extern int i;
```

**Stack**

- Непрерывная область памяти;
- Имеет методы: `push` и `pop`;
- Растет от старших адресов к младшим;
- Имеет конечный размер (обычный около 2 MiB)
- Содержит локальные переменные из функций;
- Регистр **ESP** указывает на вершину стека. Меняется каждый раз, когда слово или адрес помещаются или удаляются из стека;
- Когда вызывается функция, то создается stack frame;
- Stack frame содержит локальные аргументы функции и возвращаемое значение;

**Heap**

```cpp
void* malloc(size_t size);
void* calloc(size_t nobj, size_t size);
void* realloc(void* ptr, size_t new_size);

void free(void* ptr);
```

```cpp
int* i = static_cast<int*>(malloc(sizeof(int)));
std::string* name = new std::string();
char* data = new char[5];
...
free(i);
delete(name);
delete[] data;
```

- `new` то же, что и `malloc()`, только дополнительно вызывает конструкторы;
- `new` возвращает определённый тип, в то время как `malloc()` возвращает `void*`;
- В случае ошибки, `malloc()` вернёт `NULL`, в то время как new выбросит исключение `std::bad_alloc` exception;
- Внутри `malloc` есть буфер, если в буфере есть место, ваш вызов может выполнится быстро;

---

5. ***Указатели, интеллектуальные указатели.***

**Указатели**
Указатель - это переменная, содержащая адрес другой переменной.
Для нулевого указателя испольуется одно из: 0, `NULL` (C-style) или `nullptr` (modern C++);
`nullptr` - можно рассматривать как указатель *любого* типа;
Основной операцией над указателями является разыменование - `*` - получение объекта, на который указывает указатель
Другая операция - `&` - взятие адреса

![[Pasted image 20240716124720.png | center]]

Для любого объекта `x`, выражение `&x` возвращает адрес `x`;
Если у `x` тип `T`, то у `&x` будет тип "указатель на Т";

```cpp
int i;
unsigned long ul;
int* pi = &i;
unsigned long* pul = &ul;
```

Указатель может указывать на разные объекты в разное время в отличие от ссылок

```cpp
int a = 1, b = 2;
int* p = &a;
p = &b;
```

![[Pasted image 20240716125212.png | center]]

Ссылка всегда определена в отличие от указателя;

```cpp
char* ch = nullptr;
char& ch_ref = *ch;
```

**Интеллектуальные указатели (smart pointers)**
Объявления указателя не даёт информации о том, указывают ли они на один объект или на массив;
Объявление указателя ничего не говорит о том, должны ли вы уничтожить то, на что он указывает, когда завершите работу;
Если требуется вызвать` delete`, то причина 1 означает, что нет никакого способа узнать, следует ли использовать оператор для удаления одного объекта (`delete`) или для удаления массива (`delete []`);
Обычно нет способа выяснить, не является ли указатель висячим.

`std::unique_ptr`
- Воплощает в себя семантику исключительного владения;
- Копирование `std::unique_ptr` не разрешается;
`std::shared_ptr`
- Воплощает в себя семантику совместного владения;
- Все указатели, указывающие на объект, сотрудничают для обеспечения гарантии, его уничтожение произойдет в точке, где он станет более ненужным.
`std::weak_ptr`
- Используется для разрешения проблемы циклической зависимости.

```cpp
// Before C++17
std::shared_ptr<char> ptr(
    new char[size_],
    std::default_delete<char[]>()
)

// From C++17
std::shared_ptr<char[]> ptr(new char[size_]);
```

Полезная статья: https://www.cppstories.com/2013/02/smart-pointers-gotchas/

```cpp
void operator=(shared_ptr other) {
    if (ptr != other.ptr) {
        if (ptr && counter) {
            --(*counter)
            if (!counter->get()) {
                delete counter;
                delete ptr;
            }
        }
        ptr = other.ptr;
        if (ptr) {
            counter = other.counter;
            ++(*counter);
        }
    }
}

~shared_ptr() {
    --(*counter);
    if (!counter->get()) {
        delete counter;
        delete ptr;
    }
}
```

---

6. ***Функции, виды передачи аргументов, встраиваемые функции, перегрузка функций;***

**Функции**
Это кусок кода, который может выполнить процессор, который находится по определенному адресу;
Функция может возвращать значение, тип которого в большинстве случаев аналогичен типу самой функции;
Если функция не возвращает никакого значения, то она должна иметь тип `void` (такие функции иногда называют процедурами);
Функция может принимать параметры (а может и не принимать);
Функции можно перегружать;

*Префиксные модификаторы*
`static` указывает, что функция, не являющаяся членом класса, имеет внутреннюю связь (не будет использоваться за пределами этой единицы трансляции);
`virtual` указывает, что метод может быть переопределен дочерним классом;
`constexpr` указывает, что функция должна быть выполнена во время компиляции, если это возможно;
``[[noreturn]]`` указывает, что эта функция не возвращает значения. Этот атрибут помогает компилятору оптимизировать код;
`inline`, который играет роль в руководстве компилятором для оптимизации кода

*Суффиксные модификаторы*
`noexcept` указывает, что функция никогда не вызовет исключение. Это позволяет определенные оптимизации;
`const` указывает, что метод не будет изменять экземпляр своего класса, что позволяет ссылкам на типы `const` вызывать метод;
`final` указывает, что метод не может быть переопределен дочерним классом;
`override` указывает, что метод является переопределённым методом базового класса;
`volatile` указывает, что метод может изменить экземпляр класса

*Стек вызовов*
Поместите аргументы в регистры и в стек вызовов;
Вставьте адрес возрвата в стек вызовов;
Перейдите в вызываемой функции;
После завершения функции перейдите к адрему возврата;
Очистите стек вызовов.

**Соглашение о вызовах**

*cdecl (c-declaration)*
Перед вызовом функции вставляется код, называемый прологом (prolog) и выполняющий следующие действия:
- сохранение значений регистров, используемых внутри функции
- запись в стек аргументов функции

После вызова функции вставляется код, называемый эпилогом (epilog) и выполняющий следующие действия:
- восстановление значений регистров, сохранённых кодом пролога
- очистка стека (от локальных переменных функции)

*thiscall*
Соглашение о вызовах, используемое компиляторами для языка C++ при вызове методов классов.
Отличается от *cdecl*-соглашения только тем, что указатель на объект, для которого вызывается метод (указатель `this`), записывается в регистр ecx.

*fastcall*
Передача параметров через регистры: если для сохранения всех параметров и промежуточных результатов регистров недостаточно, используется стек (в gcc через регистры ecx и edx передаются первые 2 параметра).

**Встраиваемые функции (inline)**

*Атрибуты*
Атрибуты позволяют программистам накладывать дополнительные ограничения на исходный код и давать компилятору новые возможности для оптимизации.
Можно использовать атрибуты для типов, переменных, функций, имен и блоков кода.

`[[noreturn]]` (C++11): обозначает, что функция не возвращает значений;
`[[deprecated]]` (C++14): означает, что вы не должны использовать это имя;
`[[maybe_unused]]` (C++17): подавляет предупреждение компилятора о неиспользуемом имени
`[[nodiscard("reason")]]` (C++20): выводит предупреждение, если возвращаемое значение отбрасывается

*inline*
Указывает компилятору, что он должен пытаться каждый раз генерировать в месте вызова код, соответствующий функции;
Компилятор умный и он может не встроить код;
Тело inline-функции должно быть определено в той же единице трансляции, где она вызывается (*One definition rule* (ODR) игнорируется).

```cpp
inline void foo() {

}
```

*Просим еще найсточивее*
`__attribute__((always_inline))`
`__forceinline`
`[[gnu::always_inline]]`

Рекурсивная функция никогда не встраивается в себя!

```cpp
__attribute__((always_inline)) void foo() { }
// или
[[gnu::always_inline]] void foo() { }
```

**Перегрузка функций**
Использование одного имени для операции, выполняемой с различными типами, называется *перегрузкой*;
Функции, объявленные в различных областях видимости (не пространствах имён), не являются перегруженными;
Перегруженная функция - декорированная функция;

*Выбор версии*
1. Точное соответствие типов; то есть полное соответствие или соответствие, достигаемое тривиальными преобразованиями типов;
2. Компилятор попытается использовать целые числа и числа с плавающей точкой для получения подходящей перегрузки (например, `int` для `long `или `float` для `double`);
3. Компилятор попытается сопоставить типы, используя стандартные преобразования, такие как преобразование целочисленного типа в тип с плавающей точкой или приведение указателя на потомка к указателю на родителя;
4. Компилятор будет искать пользовательское преобразование;
5. Компилятор будет искать вариативную функцию (многоточие ...);

---

7. ***Пространство имён, функции высшего порядка, указатель на функцию, $\lambda$-функции;***

**Пространство имен**

```cpp
namespace fast { double cos(double x); }
fast::cos(x);
cos(x); // вызов из math.h
```

1. Проверка в текущем namespace;
2. Если имени нет и текущий namespace глобальный - ошибка;
3. Рекурсивно поиск в родительском namespace.

```cpp
void foo() {} // ::foo 
namespace A { 
    void foo() {} // A::foo 
    namespace B { 
        void bar() // A::B::bar { 
            foo(); // A::foo 
            ::foo(); // foo() 
        } 
    } 
}
```

**Указатель на функцию**
В общем случае объявляется так:
`возвращаемый-тип (*имя-указателя)(тип-аргумента1, тип-аргумента2, ...);`

```cpp
void foo(int x) { }
typedef void (*FooPtr)(int);
// или используя using
using FooPtr = void(*)(int);
FooPtr ptr = foo;
ptr(5);
```

**Функции высшего порядка**

```cpp
void sort(int* data, size_t size, bool (*compare)(int x, int y));

bool less(int x, int y) { return x < y; }

sort(data, 100, less);
```

**$\lambda$ - функции**

`[захват](параметры) спецификаторы -> возвращаемый тип {тело}`

Захват (captures): переменные-члены объекта функции (то есть частично примененные параметры);
Параметры (parameters): параметры необходимые для вызова объект функции;
Тело (body): код объекта функции;
Спецификаторы (specifiers): элементы вроде `constexpr`, `mutable`, `noexcept` и `[[noreturn]]`;
Тип возвращаемого значения (return type): тип, возвращаемый объектом функции.

*Список захвата*
Если не указать &, то будет захват по значению, то есть копирование объекта; если указать, то по ссылке (нет копирования, модификации внутри функции отразяться на оригинальном объекте).

```cpp
// Захват всех переменных в области видимости по значению
auto foo = [=]() {}; 
// Захват всех переменных в области видимости по ссылке 
auto foo = [&]() {};
```

```cpp
[] // без захвата переменных из внешней области видимости
[=] // все переменные захватываются по значению
[&] // все переменные захватываются по ссылке
[x, y] // захват x и y по значению
[&x, &y] // захват x и y по ссылке
[in, &out] // захват in по значению, а out — по ссылке
[=, &out1, &out2] // захват всех переменных по значению, // кроме out1 и out2, которые захватываются по ссылке
[&, x, &y] // захват всех переменных по ссылке, кроме x
```

--- 

8. *rvalue* и *lvalue*, `std::move`, оператор копирования и перемещения;

*rvalue* и *lvalue*
До стандарта С++11 было два типа значений:
1. *rvalue*
2. *lvalue*
Ссылается на объект - *lvalue* 
Если можно взять адрес - *lvalue*
Все что не *lvalue*, то *rvalue*

**Перемещение**
*Семантика*: в результате перемещения в объекте, куда происходит перемещение, должна появиться точная копия перемещаемого объекта, оригинальный объект после этого остается в неопределенном, но корректном состоянии.

![[Pasted image 20240716151513.png]]

*glvalue ("generalized" value)* - выражение, чье вычисление определяет сущность объекта
*prvalue ("pure" rvalue)* - выражение, чьё исчесление иницализирует объект или вычисляет значение операнда оператора, в соответствии с контекстом использования
*xvalue ("eXpiring" value)* - это *glvalue*, которое обозначает объект, чьи ресурсы могут быть повторно использованы (обычно потому, что они находятся около конца своего времени жизни).

*lvalue*
Выражение является *lvalue*, если ссылается на объект уже имеющий имя доступное вне выражения.

```cpp
int a = 3;
a; // lvalue
int& b = a;
b; // lvalue
int* c = &a;
*c; // lvalue
int& foo() { return a; }
foo(); // lvalue
```

*xvalue*
Результат вызова функции возвращающей *rvalue*-ссылку

```cpp
int&& foo() { return 3; }
foo(); // xvalue
```

Явное приведение к *rvalue*

```cpp
static_cast<int&&>(5); // xvalue
std::move(5); // эквивалентно static_cast<int&&>
```

Результат доступа к нестатическому члену, объекта *xvalue* значения

```cpp
struct A
{
 int i;
};
A&& foo() { return A(); }
foo().i; // xvalue
```

*prvalue*
Не принадлежит ни к *lvalue*, ни к *xvalue*.

```cpp
int foo() { return 3; }
foo(); // prvalue
```

**Copy elision**
Оптимизация компилятора разрешающая избегать лишнего вызова копирующего конструктора.

```cpp
struct A
{
 explicit A(int) {}
 A(const A&) {}
};
A y = A(5); // Копирующий конструктор вызван не будет
```

В копирующих конструкторах должна быть логика отвечающая только за копирование

--- 

9. ***Исключения, раскрутка стека, ключевое слово `noexcept`, гарантии безопасности исключений, точки следования (sequence points);***

**Исключения**

```cpp
struct Error
{
    std::string message_;
    const char* fileName_;
    int line_;
    Error(const std::string& message,
    const char* fileName, int line)
    : message_(message)
    , fileName_(fileName)
    , line_(line) {}
};

void doSomething()
{
    throw Error("doSomething error", __FILE__, __LINE__);
}
try
{
    doSomething();
}
catch (const Error& error)
{
    showError();
}
```

*Минусы*
- Вопросы производительности
- При неправильном использовании могут усложнить программу

*Плюсы*
- Нельзя проигнорировать

Исключительная ситуация - ошибка которую нельзя обработать на данном уровне и игнорирование которой делает дальнейшую работу программы бессмысленной.

**`noexcept`**

```cpp
void foo() noexcept
{
}
```

`noexcept` говорит компилятору, что функция не выбрасывает исключений — это позволяет компилятору генерировать более компактный код, но если фактически исключение было выброшено, то будет вызвана функция `terminate`

- `noexcept` является частью интерфейса функции, а это означает, что вызывающий код может зависеть от наличия данного модификатора.
- Функции, объявленные как `noexcept`, предоставляют большие возможности оптимизации, чем функции без такой спецификации
- Спецификация `noexcept` имеет особое значение для операции перемещения, обмена, функций освобождения памяти и деструкторов

**Exception safety**
*Гарантировано исключений нет (No-throw guarantee)*
Операции всегда завершаются успешно, если исключительная ситуация возникла она обрабатывается внутри операции.

*Строгая гарантия (Strong exception safety)*
Также известна как коммит ролбек семантика (commit/rollback semantics). Операции могут завершиться неудачей, но неудачные операции гарантированно не имеют побочных эффектов, поэтому все данные сохраняют свои исходные значения


```cpp
std::vector<int> source = ...;
try
{
    std::vector<int> tmp = source;
    tmp.push_back(getNumber());
    tmp.push_back(getNumber()); // <-- Исключение
    tmp.push_back(getNumber());
    source.swap(tmp);
}
catch (...)
{
    return;
}
```

*Базовая гарантия (Basic exception safety)*
Выполнение неудачных операций может вызвать побочные эффекты, но все инварианты сохраняются и нет утечек ресурсов (включая утечку памяти). Любые сохраненные данные будут содержать допустимые значения, даже если они отличаются от того, что они были до исключения.

```cpp
source.push_back(getNumber());
source.push_back(getNumber()); // <-- Исключение
source.push_back(getNumber());
```

*Никаких гарантий (No exception safety)*
Так делать не стоит.

*Иерархия исключений*

![[Pasted image 20240716162354.png]]

**Раскрутка стека**
Поиск подходящего обработчика вниз по стеку вызовов с вызовом деструкторов локальных объектов - раскрутка стека. Если подходящий обработчик не был найден вызывается стандартная функция `terminate`

Полезный ответ: https://stackoverflow.com/questions/2331316/what-is-stack-unwinding

**Исключение в конструкторе/деструкторе**
*Исключения в конструкторе*
В C++ удаляются только полностью сконструированные объекты, то есть такие, конструкторы которых уже завершили выполнение кода.

*Исключения в деструкторе*
Исключение покинувшее деструктор во время раскрутки стека или у глобального/статического объекта приведет к вызову `terminate`.

Начиная с С++11 все деструкторы компилятором воспринимаются как помеченные `noexcept` — теперь исключения не должны покидать деструктора никогда.

**Точки следования (sequence points)**
Точки следования — это точки в программе, где состояние реальной программы полностью соответствует состоянию следуемого из исходного кода.

Точки следования необходимы для того, чтобы компилятор мог делать оптимизацию кода.

*Местонахождение точек*
1. В конце каждого полного выражения - ;
2. В точке вызова функции после вычисления всех аргументов
3. Сразу после возврата функции, перед тем как любой другой код из вызываемой функции начал выполняться
4. После первого выражения (а) в следующих конструкциях: `a || b`, `a && b`, `a, b`, `a ? b : c`

```cpp
foo(
    std::shared_ptr<MyClass>(new MyClass()),
bar());
// Компилятор может заменить это выражение на следующее:
auto tmp1 = new MyClass();
auto tmp2 = bar();
auto tmp3 = std::shared_ptr<MyClass>(tmp1);
foo(tmp1, tmp3);
```

```cpp
void f(int, int);
int g();
int h();
f(g(), h());
```

По cтандарту неизвестно, какая из функций `g` или `h` будет вызвана первой, но известно, что `f()` будет вызвана последней.