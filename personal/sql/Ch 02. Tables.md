## Creating a Table
To create a new table in a database, use the `CREATE TABLE` statement followed by the name of the table and fields you want in the table.

```sql
CREATE TABLE employees (id INTEGER, name TEXT, age INTEGER, is_manager BOOLEAN, salary INTEGER);
```

Each field name is followed by its *datatype*. We'll get to data types in a minute.

It's also acceptable and common to break up the `CREATE TABLE` statement with some whitespace like this:

```sql
CREATE TABLE employees(
    id INTEGER,
    name TEXT,
    age INTEGER,
    is_manager BOOLEAN,
    salary INTEGER
);
```

### Tip
The `pragma table_info(TABLENAME);` command returns information about a table and its fields. You don't need to edit this line, I just thought you might be curious!

## Create Table Practice
In most relational databases a single table isn't enough to hold all the data we need! We *usually* create a table-per-entity. For example, a social media application might have the following tables:
- `users`
- `posts`
- `comments`
- `likes`

## Altering Tables 
We often need to alter our database schema without deleting it and re-creating it. Imagine if Twitter deleted its database each time it needed to add a feature, that would be a *disaster*! Your account and all your tweets would be wiped out on a daily basis.

Instead, we can use the `ALTER TABLE` statement to make changes in place without deleting any data.
\
### ALTER TABLE
With SQLite an `ALTER TABLE` statement allows you to:

1. **Rename a table or column**

```sql
ALTER TABLE employees
RENAME TO contractors;

ALTER TABLE contractors
RENAME COLUMN salary TO invoice;
```

2. **ADD or DROP a column**

```sql
ALTER TABLE contractors
ADD COLUMN job_title TEXT;

ALTER TABLE contractors
DROP COLUMN is_manager;
```

## Intro to Migrations
A database <u>migration</u> is a set of changes to a relational database. In fact, the `ALTER TABLE` statements we did in the last exercise were examples of migrations!

Migrations are helpful when transitioning from state to another, fixing mistakes, or adapting a database to changes.

*Good* migrations are small, incremental and ideally *reversible* changes to a database. As you can imagine, when working with large databases, making changes can be scary! We have to be careful when writing database migrations so the we don't break any systems that depend on the old database schema.

### Example of a bad migration
In the CashPal backend periodically runs a query like `SELECT * FROM people`, and we execute a database migration that alters the table name from `people` to `users` *without updating the code*, the application will break! It will try to grab data from table that no longer exists.

A simple solution to this problem would be to deploy new code that uses a new query:

```sql
SELECT * FROM users;
```

And we would deploy that code to production *immediately* following the migration.

## Migration Practice
When writing *reversible* migrations, we use the terms "up" and "down" migrations. An "up" migration is simply the set of changes you want to make, like altering/removing/adding/editing a table in some way. A "down" migration includes the changes that would *revert* any of the "up" migration's changes.

## SQL Data Types
SQL as a language can support many different data types. However, the datatypes that *your database management system (DBMS)* supports will vary depending on the specific database you're using.

SQLite only supports the most *basic* types, and we're using SQLite in this course!

### SQLite Data Types
Let's go over the <u>data types supported by SQLite</u>: and how they are stored.
1. `NULL` - Null value.
2. `INTEGER` - A signed integer stored in 0, 1, 2, 3, 4, 6 or 8 bytes.
3. `REAL` - Floating point value stored as an 64-bit <u>IEEE floating point number</u>.
4. `TEXT` - Text string stores using database encoding such as <u>UTF-8</u>
5. `BLOB` - Shore for <u>Binary large object</u> and typically used for images, audio or other multimedia.
6. `BOOLEAN` - Boolean values are written in SQLite queries as `true` or `false`, but are recorded as `1` or `0`.

### Boolean values
It's important to note - SQLite doesn't have a separate `BOOLEAN` class. Instead, boolean values are stored as integers:
- `0` = `false`
- `1` = `true`
*It's not actually all that weird, boolean values are just binary bits after all!*

SQLite will still let you write your queries using `boolean` expressing and `true`/`false` keywords, but it will convert the booleans to integers under-the-hood.


