As you're painfully aware, we've been manually managing memory throughout this course with our C code. However, Sneklang, the language we're building, has *automatic memory management*. Specifically, it makes use of a <u>garbage collector</u>. 
- In C and C++, management of heap memory is done manually with `malloc` and `free` (and `new` and `delete` in C++).
- Rust has a compile-time system that ensures memory safety.
- Zig gives the programmers access to "allocators" to manage memory.
This all examples of "manual memory management" - the programmer has to write code that keeps track of and frees memory.

### So what's a garbage collector?
A garbage collector is a program (or part of a program) that automatically frees memory that is no longer in use. Languages like Python, Java, JavaScript, OCaml, and even Go use garbage collectors *as the code is running* to manage memory. It's "automatic memory management". Automatic memory management can be a huge productivity boost for developers (less code, and sometimes fewer memory-related bugs) but it typically comes with a performance cost because, like Forest Gump, the garbage collector is always running.

It's no coincidence that C, C++, Rust,  and Zig are all great choices when you need to squeeze every last drop of performance out of your code.

## Refcounting 
One of the simplest ways to implement a garbage collector is to use a <u>reference counting</u> algorithm. It goes something like this:
- All objects keep track of a `reference_coint` integer. 
- When that object is referenced, its reference count is incremented.
- When any object that references an object is garbage collected, the reference count is decremented.
- When any object's reference count reaches zero, the object is garbage collected.

## Increment
We need to be able to increment the reference count of a `SnekObject` any time a new reference to it is created.

## Decrement and Free
Now things are going to get a touch more complicated. In a refcounting GC, the interesting stuff happens when refcount equals `0`. That's when the garbage gets collected.

When the refcount reaches 0, there are no references to this object anymore! So, we need to `free` the memory *automagically* - that's the whole point of a garbage collector.

For our first pass at this, we will only handle integers, floats and strings to keep things simple. As we go a little further, we'll implement it for the rest of the SnekObject types.

## Vectors
We have arrived at our first container type! What makes `VECTOR3` not like other types is that it *holds other snek objects*. That is, it "references" them. They are contained in its `x`, `y` and `z` fields.

When we create a vector and place objects in this fields, we need to `increment` the refcount of each of those objects! Otherwise, we might accidentally free its contents and be left with vector holding garbage memory.

## RefCounting Review
One of the great things about how we implemented our refcounting garbage collection is that the GC logic was all nicely encapsulated in the "new object" functions and the "increment/decrement refcount" functions that occur automatically within the container types. In other words, the `snek_add` function that we wrote in the last chapter will automatically handle the refcounting for us!

There's no need for us to allow any of the GC logic to leak out into the rest of the codebase.

It's pretty cool how a garbage collector can be implemented in a simple way that stays within confines of the objects themselves.