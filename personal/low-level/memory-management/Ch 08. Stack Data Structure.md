## Low Level Stack
In you've taken our data structures course, you've already implemented a <u>stack</u>. We're going to implement a stack again, but this time we're going to do it while manually managing the memory of generic pointers!

We'll get to have our first deeper exploration of "generics" in C (remember, that just means `void*`) as well as creating data structure we will later use in our mark-and-sweep garbage collector.

## Stack Push
Ok, let's actually store some data instead of just allocating memory for now practical purpose (a.k.a "haskell programming").

### Making Room 
As you know, our stack has a `count` and a `capacity`... but what happens when the `count` is equal to the `capacity`? We need to make room for more data!

We'll take a simple approach: whenever we run out of capacity, we'll double it. That way we don't have to reallocate memory on every push. For example:

|Count|Capacity|Data|
|---|---|---|
|0|4|[-, -, -, -]|
|1|4|[1, -, -, -]|
|2|4|[1, 2, -, -]|
|3|4|[1, 2, 3, -]|
|4|4|[1, 2, 3, 4]|
|5|8|[1, 2, 3, 4, 5, -, -, -]|
> [!TIP]
> The `realloc` function is used to resize memory that was previously allocated with `malloc` or `calloc`. It takes a **pointer to the old memory** and new size, and returns a pointer to the new memory:
> 

```c
void *realloc(void *ptr, size_t size);
```

```c
int *smol_boi = malloc(10 * sizeof(int));
int *large_boi = realloc(smol_boi, 20 * sizeof(int));
```

## Stack Pop
As you *should* know by now, items go on and off the stack from the same end. (last in, first out).

Don't worry, the pop method is much simpler that the push method in our case, because we don't have to worry about resizing the stack.

## Stack Free
In C, we don't have a lot of abstractions at our disposal. There's now classes, destructors, functors, monads, made-up-category-theory-words, etc.

We've got *data*. And we've got *functions*. Just the way (((God))) Denis Ritchie intended.

So, to make it easier to work with our `Stack`, we're going to build own little `free` function that will clean up all the memory that we've allocated for our stack.

## Dangerous Push
Up until now, even though we made our stack with `void*`, you'll will notice that we've only stored plain old `int` pointers. I want to show you that you can actually store *anything* in the stack, even heterogeneous lists! That being said, this is usually a bad idea.

Now, we're going to to something *pretty gross* to demonstrate the wise words of one of the philosophers of our time:

> [!QUOTE]
> With great power comes great responsibility. 
> -- Uncle Ben

I'm going to have you push an `int*` and a regular old `int` directly onto the stack (a bad idea). I just want to show you that you can store *anything* in a `void*`, even values that aren't pointer at all.

## Multiple Types
So we saw that we *can* push both `int` and `int*` types into the same stack (again, a **bad idea**).

In this example, we'll see that only can you push values and pointers into the same stack, but you can also push different types of values into the same stack.

This is once again a terrible idea, but the thrust of what we're getting at here is:

**C doesn't care what you put in memory, it's bytes all the way down.**

Fortunately, C doesn't let you do these conversions automatically... but it still lets you do them. When you're working with `void*`, you're working with raw memory addresses, and you can cast them to whatever you want.

