## Handling Cycles
We built a simple reference counting garbage collector. It can handle:
- Simple types, like `INT` and `FLOAT`.
- Dynamically allocated types, like `STRING`.
- Static Container types, like `VECTOR3`.
- Dynamic Container type, like `ARRAY`.

However, there's one little problem with our implementation. Take a look at this code:

```c
snek_object_t *first = new_snek_array(1);
snek_object_t *second = new_snek_array(1);
// refcounts: first = 1, second = 1
snek_array_set(first, 0, second);
// refcounts: first = 1, second = 2
refcount_dec(first);
// refcounts: first = 0, second = 1
refcount_dec(second);
// refcounts: first = 0, second = 0
// all free!
```

We create a `first` array, and shove the `second` array inside of it. Everything here works as expected. The trouble arises when we introduce a cycle: for example, `first` contains `second` but `second` also contains `first`...

### Observe
The reason both refcounts are stuck at one after being decremented, is because when `first` has it's refcount decremented it already has `2`. So it only drops to `1`, which does *not* trigger a "free" of the `second` array:

```c
void refcount_dec(snek_object_t *obj) {
  if (obj == NULL) {
    return;
  }
  obj->refcount--;
  if (obj->refcount == 0) {
    // this doesn't happen when refcount is 1
    return refcount_free(obj);
  }
  return;
}
```

And because `second` still has `2` refcounts, it also only drops to `1`, which fails to trigger a "free" of the `first` array.

In other words, we have a cycle, and our simple reference counting garbage collector can't handle it.

## Pros and Cons
To solve our cyclic reference issue (and to force you to implement another GC algorithm, HA!) we're going to implement a <u>Mark and Sweep</u> garbage collector.

### Pros of MaS
- Can detect cycles, and thus prevent memory leaks in certain cases.
- Less on-demand book keeping (Remember: all work done by the GC is "wasted" - it doesn't make your (((GPT-4 wrapper))) custom AI product run any faster)
- Reduces potential performance degradation in highly multi-threaded programs (refcounting requires atomic updated for thread safety)

### Cons of MaS
- More complex to implement (heh, you'll see)
- Can cause "stop-the-world" pauses when lots of objects exist and must be free (resulting in poor performance)
- Higher memory overhead
- Less predictable performance

## Stack Frames\
Think back to the warnings I was gave you about working with `void*` data types. It's easy to push the wrong kinds of data onto our `stack_t` because, like StarBucks WiFi, it well let *anything* in.

So, to prevent us from shooting ourselves in the foot, we will create some functions that are more typesafe and make it much more difficult to do the wrong thing when interacting with our `vm_t`. Wrong things like:

```c
// The C compiler won't stop us :'(
stack_push(vm->frames, (void *)7);
stack_push(vm->frames, (void *)"uh oh");
```

But we want to make it easier on ourselves to only push `frame_t*` types onto `vm->frames`, so we'll write some wrapper functions to help us out.

## Tracking Objects
Our virtual machine needs to track *every Snek object* that gets created.

We are no longer going to track how many times an object is referenced, but instead check *at garbage collection time* if each object is still referenced **at all**. If it is, keep it. If not, free it.

