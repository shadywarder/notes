## Union
Now that we understand `struct`'s and `enum`'s, we can learn about `union`'s; a combination of the two concepts.
Unions in C can hold one of several types. They're like a less-strict from the world of functional programming. Here's an example union: 
```c
typedef union AgeOrName {
  int age;
  char *name;
} age_or_name_t;
```

The `age_or_name_t` type can hold *either* an `int` or a `char *`, but not both at the same time (that would be a struct). We provide the list of possible types is so that the C compiler knows the *maximum* potential memory requirement, and can account for that. This is how the union is used:

```c
age_or_name_t lane = { .age = 29 };
printf("age: %d\n", lane.age);
// age: 29
```

Here's where it gets interesting. What happens if we try to access the `name` field (even though we *set* the `age` field)?

```c
printf("name: %s\n", lane.name);
// name:
```

We get... nothing? To be more specific, we get undefined behavior. A `union` only reserves enough space to hold the largest type in the union and the *all* of the fields **use the same memory**. So when we set `.age` to 29, we are writing the integer representation of `29` to the memory of the `lane` union:

```c
0000 0000 0000 0000 0000 0000 0001 1101
```

Then if we try to *access* `.name`, we read from the **same block of memory** but try to interpret the bytes as a `char *`, which is way we get garbage (which is interpreted as nothing in this case). **Put simply, setting the value of `.age` overwrites the value of `.name` and vice versa, and you should only access the field that you set.**

## Memory Layout
Unions store their value in the same memory location, no matter which field or type is actively being used. That means that accessing any field apart from the one you set is generally a **bad idea**.

## Union Size
A downside of unions is that the size of the union is the size of the *largest* field in the union. Take this example:

```c
typedef union IntOrErrMessage {
  int data;
  char err[256];
} int_or_err_message_t;
```

This `IntOrErrMessage` union is designed to hold an `int` 99% of the time. However, when the program encounters an error, instead of storing an integer here, it will store an error message. The trouble in that it's incredibly inefficient because it allocates 256 bytes for every `int` that is stores!

Imagine an array of 1000 `int_or_err_message_t` objects. Even if none of them make use of the `.err` field, the array will take up `256 * 1000 = 256,000` bytes of memory! An array of `int`'s would have only taken `4,000` bytes (assuming 32-bit integers),

## Helper Fields
One interesting (albeit not commonly used) trick is to use unions to create "helpers" for accessing different parts of a piece of memory. Consider the following:

```c
typedef union Color {
  struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
  } components;
  uint32_t rgba;
} color_t;
```

It results in a memory layout like this:

![](/attachments/Pasted%20image%2020241004235747.png)

Only 4 bytes are used. And, unlike 99% scenarios, it makes sense to both set *and* get values from this union through both the `components` and `rgba` fields! Both fields are exactly 32 bits in size, which means that we can "safely" (?) access the entire set of colors through the `.rgba` field, or get a single color component through the `.components` field.

The convenience of additional fields. with the efficiency of a single memory location!
