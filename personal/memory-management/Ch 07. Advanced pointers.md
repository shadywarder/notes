## Pointer-Pointers
Ok, so... now we know what pointers are. So let's learn it over again! A pointer-to-pointer in C is just a pointer valuable that holds the address of another pointer.

![[Pasted image 20241004220846.png]]

This allows you to create complex data structures like arrays of pointers, and to modify pointers indirectly. The syntax is exactly what you would expect:

```c
int value;
int *pointer;
int **pointer_pointer;
```

Pointers to pointers (or pointers to pointers to pointers to pointers... you get the idea) are like a treasure map or a scavenger hunt. You start at one pointer and keep following the chain of addresses until you get the final value. It's just a chain of dereferences.

![[Pasted image 20241004221134.png]]

```c
#include <stdio.h>
#include <stdlib.h>


void allocate_int(int **pointer_pointer, int value) {
    int* new_pointer = malloc(sizeof(int));
    *pointer_pointer = new_pointer;
    **pointer_pointer = value;
}

int main() {
    int x = 1;
    int* pointer = &x;
    int** pointer_pointer = &pointer;

    printf("%d %d %d\n", x, *pointer, **pointer_pointer);

    allocate_int(pointer_pointer, 2);

    printf("%d %d %d\n", x, *pointer, **pointer_pointer);

    free(pointer);
    
    return 0;
}
```

> [!IMPORTANT]
> In this example we only need to use `free` function for `pointer` because  `pointer_pointer` is just a local variable and it doesn't allocate memory in contrast with `pointer`, what owns memory that was allocated in `allocate_int` function using `malloc`.


## Array of Pointers
Making an array of integers on the heap is pretty simple:

```c
int *int_array = malloc(sizeof(int) * 3);
int_array[0] = 1;
int_array[1] = 2;
int_array[2] = 3;
```

But we can also make an array of pointers! it's quite common to do this in C, especially considering that strings are just pointers to `char`'s:

```c
char **string_array = malloc(sizeof(char *) * 3);
string_array[0] = "foo";
string_array[1] = "bar";
string_array[2] = "baz";
```


## Void Pointers
We've already discussed `void`, which essentially means "nothing" in C. It's used in a few different contexts:

- `void update_soldier(soldier_t* s)`: means the function returns nothing
- `soldier_t new_soldier(void)`: means the function takes no arguments.

And, because C likes re-using ideas but with slightly different meaning (the genius of the design can't be understood by us mere mortals) `void` also has another use!

A `void*` "void pointer" tells the compiler is that this pointer could point to **anything**. This is why void pointers are also know as a "generic pointers". Since void pointers do not have a specific data type, they cannot be directly dereferenced or used in pointer arithmetic without casting them to another pointer type first.

### Casting to Void Pointers
Casting to and from void pointers in C is unique because void pointers are type-agnostic. When casting a specific type pointer to a void pointer, no type information is retained, allowing the void pointer to point to any data type. However, you **must** cast a void pointer back to its original type before dereferencing it, as direct dereferencing is not possible.

```c
int number = 42;
void *generic_ptr = &number;

// This doesn't work
printf("Value of number: %d\n", *generic_ptr);

// This works: Cast to appropriate type before dereferencing
printf("Value of number: %d\n", *(int*)generic_ptr);
```

A common pattern is to store generic data in one variable, and the type of that data in another variable. This is useful when you need to pass data around without knowing its type in compile time.

```c
typedef enum DATA_TYPE {
  INT,
  FLOAT
} data_type_t;

void printValue(void *ptr, data_type_t type) {
  if (type == INT) {
    printf("Value: %d\n", *(int*)ptr);
  } else if (type == FLOAT) {
    printf("Value: %f\n", *(float*)ptr);
  }
}

int number = 42;
printValue(&number, INT);

float decimal = 3.14;
printValue(&decimal, FLOAT);
```

## Generic Swap
For the previous `swap` implementations we've known the type of the data we want to swap. Because we knew the type, the compiler knew the sizes of the data we want to swap.

However, to make a generic swap, we will need to provide the C compiler with the size of the data we are swapping because `void*` loses that type info. Our new interface for `swap` will include the size:

```c
void swap(void *vp1, void *vp2, size_t size);
```

The other problem we're going to have is that directly assigning pointer values does not work the same way with `void*`. Instead of using `*ptr1 = *ptr2`, we will use `memcpy`, which is included in the `string.h` library:

```c
void *memcpy(void *destination, void* source, size_t size);
```

So to move the data from `ptr2` to `ptr1`, we ill use the following:

```c
memcpy(ptr1, ptr2, size);
```

Generic swap implementation in C:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void swap(void* vp1, void* vp2, size_t size) {
    void* vp3 = malloc(size);
    if (!vp3) { return; }

    memcpy(vp3, vp1, size);
    memcpy(vp1, vp2, size);
    memcpy(vp2, vp3, size);
}

int main() {
    char* a = "abc";
    char* b = "def";

    printf("%s %s\n", a, b);
    
    swap(&a, &b, sizeof(a));

    printf("%s %s\n", a, b);
    
    return 0;
}
```

