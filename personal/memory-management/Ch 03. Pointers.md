## Memory
Before we talk about pointers, we should talk about variables and memory in general. Here are some useful (albeit hand-way) mental models:

> [!NOTE]
> Variables are human readable names that refer to some data in memory.

> [!NOTE]
> Memory is a big array of bytes, and data is stored in the array.

A variable is a human readable name that refers to an address in memory, which is an index into the big array of bytes. Here's a diagram:

![](attachments/Pasted%20image%2020241004235647.png)

### Getting a Variable's Address
In C, you can print the address of a variable by using the address-of-operator `&`. Here's an example:

```c
#include <stdio.h>

int main() {
  int age = 37;
  printf("The address of age is: %p\n", &age);
  return 0;
}

// The address of age is: 0xfff8
```

*Note: The `%p` format specifier will format a pointer (memory address) to be printed.*

## What is an Address?
So I mentioned in the last lesson that memory can be thought of as a big array of bytes, and each byte has an address.

That's true, and the beauty is that each address is *literally just a number*. It's not some *mortal* address "1234 Elm St." or "1600 Pennsylvania Ave.". It's **just a number**.

You might be thinking, "Hey, if it's just a number, why does it look all disgusting like `0xfff8`?"

That's because `0xfff8` *is* just a number. But:
1. It's written in `hexadecimal` (base 16) instead if decimal (base 10).
2. It's pretty big number, so it's not very human readable. `0xfff8` is the same as `65,528` in decimal.

![](attachments/Pasted%20image%2020241004235717.png)

## Virtual Memory
As it turns out, your code probably doesn't have direct access to the physical RAM in your computer.
Instead, your operating system provides a layer of abstraction called **virtual memory**. Virtual memory makes it seem like your program has direct access to all the memory on the machine, even if it doesn't.
- **Physical Memory**: The actual RAM sticks in your computer.
- **Operating System**: The software that manages access to the physical memory.
- **Your Program**: When it runs, it becomes a <u>process</u> and is given access to a chunk of virtual memory by the operating system.
- **Virtual Memory**: This abstracted chunk of memory that your program can use.
*There are exceptions to this, for example if you're using C to build embedded firmware that runs without an operating system, your code might interact directly with physical memory.*

![](attachments/Pasted%20image%2020241004235727.png)

By only giving processes access to a chuck of virtual memory, the operating system can do some cool things:
1. **Isolation**: One process can't access the memory of another process.
2. **Security**: The operating system can prevent processes from accessing certain parts of memory.
3. **Simplicity**: Developers don't have to worry about managing physical memory and the memory of other processes.
4. **Performance:** The operating system can optimize memory access depending on the hardware and need of the program. For example, by moving data between physical memory and the hard drive.
At the end of the day, your program had direct access to a virtual chunk of memory. Just like physical memory, it can be thought of as a big array of bytes, where each byte has an address.

## Pointers
In fact, now that you understand how memory is laid out in an array, a lot of the mystery behind pointers should be gone. Put simply: **a pointer is just a variable that stores a memory address**. It's called a pointer, because it "points" to the address of a variable, which stores the actual data held in that variable.