## Язык Ассемблера
### Регистры x86
- Указатель команд - `RIP`
- Флаговый регистр - `RFLAGS`
- Регистры общего назначения:
	- указатель стека - `RSP`;
	- указатель "базы" - `RBP`;
	- `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `R8` - `R15`

### Инструкции беззнакового умножения и деления

```asm
mulq <op>
```

В качестве второго операнда всегда выступает регистр `RAX`, куда записываются 64 младших бита числа, получившегося в результате умножения. Старшие 64 бита хранятся в `RDX`

```asm
RAX = (<op> x RAX) mod 2^64
RDX = (<op> x RAX) / 2^64
```

```asm
divq <op>
```

В случае деления, остаток от него попадает в регистр `RDX`, а само частное будет в `RAX`.

```asm
RDX = (RDX x 2^64 + RAX) mod <op>
RAX = (RDX x 2^64 + RAX) / <op>
```

### Стек

![](/attachments/Pasted%20image%2020241009010913.png)

### Инструкции работы со стеком
- `pushq <src>` - уменьшает `RSP` на 8 и сохраняет по полученному адресу `src`
- `popq <dst>` - обратное действие к `pushq`
	- `popq %RAX`
- Мы можем просто посмотреть значение, которое лежит на вершине стека, не удаляя его: `movq (%RSP), %RAX`
### Метки и переменные
Метка - просто имя для некоторого адреса

```asm
.data

value:
	.quad 42

	.text

add42:
	movq %rdi, %rax
	addq value, %rax
	retq
```

### Инструкции безусловного перехода
Инструкции безусловного перехода изменяют значение регистра `RIP`:
- `jmp <label>`
- `call <label>` - инструкция вызова функции
- `retq` - инструкция возврата из функции


### Функции
Функция:
- функцию можно вызвать;
- функция возвращает управление *вызвавшему коду*.



### Вызов функции

![](../../attachments/Pasted%20image%2020241011200252.png)

1. Адрес возврата (адрес следующий инструкции после функции) кладется на стек.
2. Управление передается функции.
3. Функция завершится вызовом `retq`, которая заглянет на стек, возьмет адрес следующей инструкции после функции со стека, удалит его и передаст ему управление.

> [!IMPORTANT] 
> Если внутри функции `add42` мы добавляли что-то на стек, то мы должны удалить это, потому что иначе мы передадим управления непонятно куда. (на вершине стека должен лежать адрес возврата)

### Флаговый регистр
- Флаговый регистр хранит флаги!
- Флаги регистра `RFLAGS`
	- `ZF` - результат операции 0;
	- `CF` - произошло беззнаковое переполнение (результат сложения двух чисел не поместился в 64 бита);
	- `OF` - произошло знаковое переполнение.

### Инструкции условного перехода
- `jcc <label>` - выполняет переход, если условие `cc` истинно
	- `jz`, `je` - проверяет, что `ZF = 1`;

```asm
subq $42, %RAX
je do_smth
```

- `jne`, `jnz` - `ZF = 0`;
- `jg` - если больше (знаковый вариант);
- `jge` - "больше или равно" (знаковый вариант);
- `ja` - если "больше" (беззнаковый вариант);
- `jae` - "больше или равно" (беззнаковый вариант)

### Инструкции сравнения
- Арифметические инструкции изменяют `RFLAGS`, но также изменяют свои аргументы!
- Есть команды, которые выставляют флаги, но не изменяют свой аргументы:
	- `cmpq <src>, <dst>` - вычисляет разность `dst - src` и выставляет флаги;
	- т.е. `cmpq` работает как `subq`, но не изменяет `dst`.
- Напишем функцию, которая вычисляет максимум из переданных ей аргументов. В регистре `%rax` будем хранить максимум.

```asm
max:
	movq %rdi, %rax
	cmpq %rsi, %rdi # rdi - rsi
	ja rdi_gt       # rdi - rsi > 0 
	movq %rsi, %rax
rdi_gt:
	ret
```

 функцию pow, которая принимает на вход два беззнаковых числа `x` и `p` (в регистрах `%RDI` и `%RSI` соответственно) и возвращает значение $x^p$ в регистре `%RAX`.

> [!NOTE]
> Результат инструкции `mulq` сохраняется в регистре `%RAX`.

```asm
pow:
	movq $1, %RAX

	cmpq $0, %RSI
	je done

	call loop

	retq

loop:
	mulq %RDI
	subq $1, %RSI
	jnz loop # if we'll use call here will be getting segfault due to    overflow

done:
	retq
```

### Про разницу условных переходов `je` и `jz`
`JE` and `JZ` are just different names for exactly the same thing: a conditional jump when `ZF` (the "zero" flag) is equal to 1.

You _could_ use them interchangeably, but you _should_ use them depending on what you are doing:

- `JZ`/`JNZ` are more appropriate when you are explicitly testing for something being equal to zero:
    
    ```
    dec  ecx
    jz   counter_is_now_zero
    ```
    
- `JE` and `JNE` are more appropriate after a `CMP` instruction:
    
    ```
    cmp  edx, 42
    je   the_answer_is_42
    ```

### Соглашения
ABI (Application Binary Interface) - набор соглашений
- как в функцию передаются параметры;
- как функция возвращает значения;
- какие регистры функция должна сохранить, а какие может испортить;
- и многое другое.

ABI для нас важен с той точки зрения, что мы будем вызывать ассемблерные функции с сишного кода, и наоборот.

### Различные ABI
Разные компиляторы используют различные ABI:
- например, Microsoft используют свой собственный *ABI*;
- Unix-like системы, зачастую, используют *System V ABI*.

## Прерывания
### Прерывание
Прерывание - это событие, которое заставляет процессор *прервать* текущую задачу и вызвать специальный обработчик
- внешнее устройство требует внимание (сетевая карта говорит процессору забрать ее данные);
- произошла ошибка при выполнении инструкции (деление на ноль);
- специальная инструкция.

Прерывания могут происходить асинхронно
- т. е. код не готов к тому что его прервут
- т. е. обработчик прерывания ответственнен за сохранение состояния прерваной задачи.

### Обработчики прерываний
Откуда берутся обработчики прерываний?
- часть ядра ОС;
- ОС сообщает процессору, какой обработчики вызывать в какой ситуации и где они лежат.

### Вызов обработчика прерывания
Вызов обработчика прерывания чем-то напоминает вызов функции, т. е. когда обработчик прерывания завершается, он скорее всего должен вернуть управление прерванному коду. 

![](../../attachments/Pasted%20image%2020241011222255.png)

**Error code**
Некоторые прерывания соответсвуют ошибочным ситуациям
- для некоторых из них на стек сохраняется Error Code.
Error code, *иногда*, содержит полезную для обработки ошибки информацию, а иногда он просто содержит 0.

### Завершение обработчика прерывания
Обработчик прерывания *обычно* завершается инструкцией `iretq`.
- для прерываний, сохраняющих Error Code, его *необходимо* удалить со стека.

### Тело обработчика прерывания
В общем случае зависит от прерывания
- например, прерывания от сетевой карты и от таймера требуют разной обработки;

Общая часть - сохранение состояния прерванной задачи:
- `RIP` и `FLAGS` не достаточно;
- как минимум, нужно сохранить регистры общего назначения (мы не должны затирать их данные).

### Таблица дескрипторов прерываний
IDT указывает, каким прерываниям какие обработчики соответствуют
- специальные регистр `IDTR` хранит адрес этой таблицы;
- инструкции `LIDT` и `SIDT` позволяют записать/прочитать регистр `IDTR`.


![](../../attachments/Pasted%20image%2020241011223135.png)

Поля Offset хранят 64-битный адрес обработчика, который нужно вызывать. 

IDT может содержать максимум 256 записей (можем записать больше, но это никак не отобразится)
- т. е. каждое ядро может обрабатывать 256 различных прерываний;
- первые 32 из 256 зарезервированы под специальные нужды;
- оставшиеся 224 записи используются для обработки прерываний от внешних устройств.

Какой устройство какую запись в IDT использует?
- может определяться настройкой устройства (храниться в его драйверах);
- может определяться настройкой контроллера прерываний.

### Контроллер прерываний
Контроллер прерываний - посредник между устройствами и процессором
- устройства сигналят контроллеру, контроллер сигналит процессору
- задача контроллера - арбитраж (порядок обработки прерываний).

Примеры контроллеров:
- PIC (Programmable Interrupt Controller) (Intel 8259);
- APIC (Advanced PIC) (Local APIC + IO APIC).

### Запрет прерываний
Зачем запрещать прерывания?
- задача работает с данными, к которым обращается обработчик.

> [!NOTE]
> Задача, выполняемая на процессере, обновляет какую-то сложную структуру данных (чтобы обновить, требуется несколько операций, т. е. мы не можем сделать это атомарно). Если в середине этого обновления нас прервут, то она останется неконсистентном состоянии, ведь мы не успели завершил обновление. Обращения обработчика прерываний к этой структуре данных в таком состоянии можем привести к ошибкам.

Получается, мы хотим запретить прерывания, пока мы не завершили подобные обновления.

Ккакие прерывания можно запрещать?
- нельзя запрещать исключения (прерывания из-за ошибок)
В таких ситуациях процессор не знает, что ему делать дальше и запрет никак не повлияет на ситуацию.

- Мы можем попросить устройство не генерировать прерывания
	- если мы знаем, какие прерывания могут привести к проблемам;
	- если устройство позволяет.
- Отключить прерывание на контроллере прерываний
- Отключить прерывание на процессере
	- x86 регистр `RFLAGS` содержит флаг `IF`;
	- инструкция `cli` очищает флаг - запрещает прерывания;
	- инструкция `sti` устанавливает флаг.

## Загрузка ОС
### Первая инструкция
Откуда берется первая инструкция?
- x86 обращается по адресу `OxFFFFFFF0`;
- отвечает ему материнская плата.
Какой код материнская плата отдает процессору?
- BIOS (Basic Input/Output System) - наследство *IBM PC*;
- UEFI (Unified Extensible Firmware Interface).

### BIOS
POST (Power-On Self-Test)
- проверяет, что все на месте и "работает";
- может выполнять начальную инициализацию устройств;
- ищет загрузочное устройство (диск в ОС).

BIOS ищет диск, с которого можно прочитать первые 512 байт a. k. a. загрузочной сектор.
- последние 2 байта сектора должны хранить числа `Ox55` и `OxAA`;
- сектор загружается в память **по физическому адресу** `Ox7c00`.
BIOS передает управление по физическому адресу `0x7c00`
- мы добрались до места, где мы можем на что-то повлиять (мы можем положить сюда свой код)

### Окружение
Что нам известно о состоянии системы?
- наш код начинается по физическому адресу `0x7c00`;

*Remark:* Физический адрес выставляет процессор, когда обращается к памяти, т. е. это адрес указанной в запросе процессора к внешним устройствам.  Логический адрес - это тот адрес, который принимает программа. Логический адрес не всегда равен физическому.

- устройства как-то инициализированы и прерывания отключены;
- процессор работает в *Real Mode*.

### Real Mode
Логический адрес состоит из двух частей:
- 16-битного сегмента (*SEG*) и 16-битного смещения (*OFF*);
- физический адрес получается по формуле (*SEG* * 16 + *OFF*) *mod $2^{20}$*.

Сегмент хранитсяв одном из специальных регистров:
- `CS`, `DS`, `SS`, `ES`, `FS`, `GS`

Как определяется какой из сегментныз регистров использовать? Чаще всего, в программе не указано явно, какой следует использовать
`CS` - процессор обращается к памяти, чтобы достать следующую инструкцию
`SS` - инструкция для работы со стеком (`pushq`, `popq`, `call`)
`DS`, `ES` - скопировать из одного места в памяти в другое

Регистры общего назначения 16-битные:
- `SP` - указатель стека;
- `BP` - указатель "базы";
- `AX`, `BX`, `CX`, `DX`, `SI`, `DI`.

`CS` - code segment
`DS` - data segment
`SS` - stack segment

![](../../attachments/Pasted%20image%2020241012000123.png)

Hello, World!

```asm
	.code16
	.text
	.global start
start:
	ljmp 0x0, $real_start # CS <- 0, IP <- $real_start
real_start:
	movw $0, %ax # suffix w mean 16-bit operands
	movw %ax, %ds # movw $0, %ds is restricted
	movw %ax, %ss

	movw $0x7c00, %sp 
	addw $0x0400, %sp
	...
loop: 
	jmp loop
```

```asm
	movw $0xB800, %ax # 0xB800 video buffer address
	movw %ax, %es # $es, di - where we want to copy data
	movw $data, %si # es - segment register 
	movw $0, $di  
	movw size, %cx
	call memcpy # %ds - segment, %si - size of data
data:
	.asciz "H\017e\017l\017l\017o\017!\017"
size
	.short .- data
```

```asm
memcpy:
	cmpw $0, %cx
	jz out
next:
	movb (%si), %ah
	movb %ah, %es:(%di) # shift 
	incw %si # further data access
	incw $di # further video buffer interaction
	decw %cx
	jnz next
out:
	ret
```

### Начальный загрузчик
Как много кода можно поместить в первые 510 байт?
- вряд ли туда поместится целая современная ОС;
- задача этого кода прочитать с диска код, не поместившийся в первые 510 байт.

Оставшийся код может быть кодом ОС,
- а может быть кодом (вторичного загрузчика);
- например, GRUB

