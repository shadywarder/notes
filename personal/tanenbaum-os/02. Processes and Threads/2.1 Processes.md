In any multiprogramming system, the CPU switches from process to process quickly, running each for tens or hundreds of milliseconds. While, strictly speaking, at any instant the CPU is running only one process, in the course of 1 seconds it may work on several of them, giving the illusion of parallelism. Sometimes people speak of **pseudoparallelism** in this context, to contrast it with true hardware parallelism of **multiprocessor** systems (which have two or more CPUs sharing the same physical memory).

## 2.1.1 The Process Model

A process is just an instance of an executing program, including the current values of the program counter, registers, and variables. Conceptually, each process has its own virtual CPU.

We can think about a collection of process running in (pseudo) parallel
than to try to keep track of how the CPU switches from program to program. This
rapid switching back and forth is called **multiprogramming**.

![[Pasted image 20240916163420.png]]

The difference between program and process is similar to difference between recipe and actual cooking process.

The process has a program, input, output, and a state.

## 2.1.2 Process Creation
Four principal events cause processes to be created:
1. System initialization.
2. Execution of a process-creation system call by a running process.
3. A user request to create a new process.
4. Initiation of a batch job.

Processes that stay in the background to handle some activity such as email, Web pages, news printing, and so on are called **daemons**.

In UNIX, there is only system call to create a new process: `fork`. This call creates an exact clone of the calling process. After the `fork`, the two processes, the parent and the child, have the same memory image, same environment strings, and the same open files.
Usually, the child process then executes `execve` or a similar system call to change its memory image and run a new program. For example, when a user types a command say, `sort`, to the shell, the shell forks off a child process and the child executes `sort`.

In both UNIX and Windows systems, after a process is created, the parent and child have their own distinct address spaces. If either process changes a word in its address space, the change is not visible to the other process. In UNIX, the child's initial address space is a *copy* of parent's, but there are definitely two distinct address spaces involved; no writable memory is shared. Some UNIX implementations share the program text between two since that cannot be modified. Alternatively, the child may have share all of the parent's memory, but in that case the memory is shared **copy-on-write**.

## 2.1.3 Process Termination
Sooner or later the new process will terminate, usually due to one of the following conditions:
1. Normal exit (voluntary) - process done its work.
2. Error exit (voluntary) - for example, compilation of non-existing file.
3. Fatal error (involuntary) - often due to a program bug.
4. Killed by another process (involuntary) - the process executes a system call telling the operating system to kill some other process.

## 2.1.4 Process Hierarchies
The child process can itself create more processes, forming a process hierarchy. A process has only one parent (but zero, one, two, or more children).

In UNIX, a process and all of its children and further descendants together form a process group. When a user sends a signal from the keyboard, the signal is delivered to all members of the process group currently associated with the keyboard. 

A special process, called *init*, is present in the boot image. When it starts running, it reads a file telling how many terminals there are. Then it forks off a new process per terminal. These processes wait for someone to log in. If a login is successful, the login process executes a shell to accept commands. These commands may start up more processes, and so forth. Thus, all the processes in the whole system belong to a system tree, with *init* at the root.

## 2.1.5 Process States
Although each process is an independent entity, with its own program counter and internal state, processes often need to interact with other processes. One process may generate some output that another process as input.

```Shell
cat chapter1 chapter2 chapter3 | grep tree
```

When a process blocks, it does because logically it cannot continue, typically because it is waiting for input that is not yet available. It is also possible for a process that is conceptually ready and able to run to be stopped because the operating system decided to allocate the CPU to another process for a while

![[Pasted image 20240916171755.png]]

- Transition 1 occurs when the operating system discovers that a process cannot continue right now.
Transition 2 and 3 are caused by the process scheduler, a part of the operating system, without the process even knowing about them.
- Transition 2 occurs when the scheduler decides that the running process has run long enough, and it is time to let another process have some CPU time. 
- Transition 3 occurs when all the other processes have had their fair share and it is time for the first process to get the CPU to run again,
- Transition 3 occurs when the external event for which a process was waiting (such as arrival of some input) happens.

![[Pasted image 20240916172437.png]]

## 2.1.6 Implementation of Processes
To implement the process model, the operating system maintains a table (an array of structures), called the **process table**, with one entry per process. This entry contains important information about the process' state, that must be saved when the process is switched from *running* to *ready* or *blocked* state so that it can be restarted later as if had never been stopped.

Associated with each I/O class is a location (typically at a fixed location near the bottom of memory) called the **interrupt vector**. It contains the address of the interrupt service procedure.

![[Pasted image 20240916173115.png]]

All interrupts start by saving the registers, often in the process table entry for the current process. Then the information pushed onto the stack by the interrupt is removed and the stack is set to point to a temporary stack used by the process handler. Such actions are performed by a small assembly-language routine.

A process may be interrupted thousands of times during its execution, but the key idea is that after each interrupt the interrupted process returns to precisely same state it was in before the interrupt occurred.

## 2.1.7 Modeling Multiprogramming
When multiprogramming is used, the CPU utilization can be improved. Crudely put, if the average process computes only 20% of the time it is sitting in memory, then with five processes in memory at once the CPU should be busy all the time. 

![[Pasted image 20240916173916.png]]

